<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Floaty Fish: Ocean Adventure (God Mode Build)</title>
    <link href="https://fonts.googleapis.com/css2?family=Bungee&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; padding: 0; background-color: #0d1b2a; display: flex; justify-content: center; align-items: center; height: 100vh; font-family: 'Bungee', cursive; color: white; overflow: hidden; touch-action: manipulation; }
        #app-wrapper { display: flex; flex-direction: column; align-items: center; width: 95vw; max-width: 500px; }
        @media (orientation: landscape) { #app-wrapper { height: 95vh; flex-direction: row; align-items: center; justify-content: center; max-width: none; } #game-container { height: 100%; width: auto; } }

        #game-ui-header { width: 100%; padding: 10px 15px; box-sizing: border-box; background-color: #1a2a3a; display: none; flex-direction: column; justify-content: center; align-items: center; border-radius: 10px 10px 0 0; }
        #ui-top-row { display: flex; justify-content: space-between; align-items: center; width: 100%; }
        #score-display { font-size: 1.8rem; text-shadow: 2px 2px 3px #000; }
        #ui-center-group { display: flex; flex-direction: column; align-items: center; }
        #god-mode-indicator { display: none; color: gold; font-size: 1rem; font-weight: bold; text-shadow: 1px 1px 2px #000; order: 1; }
        #lives-display { display: flex; gap: 5px; order: 2; }
        #lives-display img { width: 28px; height: 28px; }
        #pause-button { background: none; border: none; font-size: 2rem; color: white; cursor: pointer; padding: 0 5px; text-shadow: 2px 2px 3px #000; }
        #ui-level-info { display: flex; flex-direction: column; align-items: center; margin-top: 8px; width: 100%; }
        #ui-level-name { font-size: 0.8rem; margin-bottom: 5px; }
        #progress-bar-container { width: 100%; height: 12px; background-color: rgba(0, 0, 0, 0.5); border: 1px solid white; border-radius: 10px; }
        #progress-bar { width: 0%; height: 100%; background-color: #ffde59; border-radius: 8px; transition: width 0.1s linear; }

        #game-container { position: relative; overflow: hidden; border: 3px solid #FFF; box-shadow: 0 0 20px rgba(0, 255, 255, 0.5); background-color: #000; aspect-ratio: 480 / 560; width: 100%; }
        @media (min-width: 1024px) { #app-wrapper { max-height: 90vh; } #game-container { max-height: calc(90vh - 100px); }}
        
        canvas { display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        .ui-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center; text-shadow: 2px 2px 4px #000000; z-index: 20; padding: 20px; box-sizing: border-box; }
        #loading-screen, #how-to-play-screen, #main-menu, #game-over-screen, #fish-selection-modal, #life-lost-screen, #level-start-screen, #unlock-screen, #quit-warning-screen, #equip-confirm-screen, #pause-screen { background-color: rgba(0, 0, 0, 0.7); backdrop-filter: blur(8px); }
        h1 { font-size: 3rem; margin-bottom: 10px; line-height: 1.1; color: #ffde59; }
        h2 { font-size: 1.5rem; margin: 10px 0; }
        p { font-size: 1.1rem; margin: 10px 0 15px 0; line-height: 1.4; max-width: 90%; }
        .button { padding: 15px 30px; font-size: 1.5rem; font-family: 'Bungee', cursive; background-color: #ffde59; color: #0d1b2a; border: none; border-radius: 10px; cursor: pointer; margin-top: 20px; text-shadow: none; transition: transform 0.1s ease; box-shadow: 0 5px 0 #c7a100; }
        .button:active { transform: translateY(5px); box-shadow: 0 0 0 #c7a100; }
        .secondary-button { background-color: #4ecdc4; box-shadow: 0 5px 0 #2a9d8f; }
        .secondary-button:active { box-shadow: 0 0 0 #2a9d8f; }
        .button-group { display: flex; gap: 15px; }
        .button-group.hidden { display: none; }
        .god-mode-toggle-button { background-color: #806c00; color: gold; border-radius: 50%; width: 60px; height: 60px; padding: 0; font-size: 2rem; margin-top: 15px; border: 2px solid gold; box-shadow: 0 4px 0 #5c4e00; }
        .god-mode-toggle-button:active { box-shadow: 0 0 0 #5c4e00; }
        .god-mode-toggle-button.active { background-color: gold; color: #333; box-shadow: 0 0 20px gold; }
        #perfect-pass-text { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 3rem; color: #00ff00; text-shadow: 3px 3px 0 #000, -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000; opacity: 0; transition: opacity 0.5s ease-out; pointer-events: none; z-index: 6; }
        #fish-selection-modal { background-color: rgba(13, 27, 42, 0.9); justify-content: flex-start; transition: filter 0.3s ease-out; }
        #fish-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; margin-top: 20px; overflow-y: auto; flex-grow: 1; width: 100%; padding-right: 15px; min-height: 0; }
        .fish-option { cursor: pointer; padding: 5px; border-radius: 10px; border: 3px solid transparent; transition: all 0.2s ease; }
        .fish-option.selected { border-color: #ffde59; background-color: rgba(255, 222, 89, 0.2); transform: scale(1.05); }
        .fish-option.locked { cursor: default; filter: grayscale(1) brightness(0.6); }
        .fish-option img { width: 100px; height: 100px; object-fit: contain; margin-bottom: 5px; }
        .fish-option span { font-size: 0.8rem; }
        #level-start-obstacle-img { width: 120px; height: 120px; margin: 15px 0; }
        #level-start-lives { display: flex; gap: 8px; }
        #level-start-lives img { width: 40px; height: 40px; }
        #unlock-animation-container { position: relative; width: 150px; height: 150px; margin: 15px 0; cursor: pointer; }
        #unlocked-skin-img { width: 100%; height: 100%; position: absolute; top: 0; left: 0; }
        #unlock-animation-img { width: 100%; height: 100%; position: absolute; top: 0; left: 0; transition: clip-path 0.1s linear, opacity 0.5s ease-out; }
        #tap-to-reveal-text { margin: 15px 0 0 0; color: #ffde59; }
        .shake-on-tap { animation: tap-shake 0.3s ease-in-out; }
        @keyframes tap-shake { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-6px) rotate(-3deg); } 50% { transform: translateX(6px) rotate(3deg); } 75% { transform: translateX(-4px) rotate(-2deg); } }
        .pop-in { animation: revealPop 0.4s ease-out 0.1s both; }
        @keyframes revealPop { 0% { transform: scale(0.8); opacity: 0.8; } 70% { transform: scale(1.1); } 100% { transform: scale(1); opacity: 1; } }
        #unlock-animation-img.fade-out { opacity: 0; }
        #new-best-record-display { display: none; color: #00ff00; animation: revealPop 0.5s ease-out; }
        #screen-flash { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: white; opacity: 0; z-index: 25; pointer-events: none; }
        #screen-flash.active { animation: flash 0.2s; }
        @keyframes flash { from { opacity: 0.7; } to { opacity: 0; } }
        #shock-effect { position: absolute; z-index: 26; width: 120px; height: 120px; pointer-events: none; transform: translate(-50%, -50%); }
    </style>
</head>
<body>
    <div id="app-wrapper">
        <div id="game-ui-header">
            <div id="ui-top-row">
                <div id="score-display">0</div>
                <div id="ui-center-group">
                    <div id="god-mode-indicator">GOD MODE</div>
                    <div id="lives-display"></div>
                </div>
                <button id="pause-button">‚è∏Ô∏è</button>
            </div>
            <div id="ui-level-info">
                <div id="ui-level-name">Tangle Reef</div>
                <div id="progress-bar-container">
                    <div id="progress-bar"></div>
                </div>
            </div>
        </div>
        <div id="game-container">
            <canvas id="game-canvas"></canvas>
            <div id="screen-flash"></div><img id="shock-effect" src="" style="display: none;">
            <div id="loading-screen" class="ui-overlay"><h1>Loading Adventure</h1><p id="loading-progress">0%</p></div>
            <div id="how-to-play-screen" class="ui-overlay" style="display: none;"><h1>How to Play</h1><p>Tap or [SPACE] to swim up. Avoid everything!</p><p>Press [G] to toggle God Mode for testing.</p><button id="god-mode-button-htp" class="god-mode-toggle-button">üî±</button><p style="font-size: 0.8rem; max-width: 80%; color: #aaa; margin-top: 10px;">God mode does not track any points or distance. You will not unlock anything. We don't condone cheating this is for beta testing only!</p><button id="close-how-to-play-button" class="button">Let's Go!</button></div>
            <div id="perfect-pass-text">PERFECT!</div>
            <div id="main-menu" class="ui-overlay" style="display: none;"><h1>Floaty Fish</h1><h2 id="main-menu-best-score">BEST SCORE: 0</h2><h2 id="main-menu-best-distance">BEST DIST: 0m</h2><button id="start-game-button" class="button">Start Game</button><button id="fish-button" class="button secondary-button">Fish</button></div>
            <div id="pause-screen" class="ui-overlay" style="display: none;"><h1>Paused</h1><div class="button-group"><button id="resume-button" class="button">Resume</button><button id="pause-quit-button" class="button secondary-button">Quit</button></div></div>
            <div id="level-start-screen" class="ui-overlay" style="display: none;"><h1 id="level-start-name">Level Name</h1><p>Obstacle:</p><img id="level-start-obstacle-img" src="" alt="Obstacle"><div id="level-start-lives"></div><div class="button-group"><button id="begin-level-button" class="button">Begin!</button><button id="level-start-home-button" class="button secondary-button">Menu</button></div><button id="god-mode-button-ls" class="god-mode-toggle-button">üî±</button></div>
            <div id="life-lost-screen" class="ui-overlay" style="display: none;"><h1>Life Lost!</h1><h2 id="lives-remaining-display">2 Lives Remaining</h2><div class="button-group"><button id="continue-button" class="button">Continue</button><button id="life-lost-home-button" class="button secondary-button">Menu</button></div></div>
            <div id="game-over-screen" class="ui-overlay" style="display: none;"><h1>Game Over</h1><h2 id="new-best-record-display">New Best Distance!</h2><h2 id="final-score-display">SCORE: 0</h2><h2 id="best-score-display">BEST: 0</h2><h2 id="final-distance-display">DISTANCE: 0m</h2><h2 id="best-distance-display">BEST: 0m</h2><div class="button-group"><button id="restart-button" class="button">Try Again</button><button id="home-button" class="button secondary-button">Main Menu</button></div></div>
            <div id="fish-selection-modal" class="ui-overlay" style="display: none;"><h1>Select Your Fish</h1><p>Unlock new skins by reaching new levels!</p><div id="fish-grid"></div><button id="close-fish-modal-button" class="button">Back</button></div>
            <div id="unlock-screen" class="ui-overlay" style="display: none;"><h1>New Fish Unlocked!</h1><p id="unlocked-skin-name">Fish Name</p><h2 id="tap-to-reveal-text">Tap to Reveal!</h2><div id="unlock-animation-container"><img id="unlocked-skin-img" src=""><img id="unlock-animation-img" src=""></div><div class="button-group hidden" id="unlock-buttons"><button id="equip-unlocked-skin-button" class="button">Equip Now</button><button id="continue-without-equipping-button" class="button secondary-button">Continue</button></div></div>
            <div id="quit-warning-screen" class="ui-overlay" style="display: none;"><h1>Are you sure?</h1><p>Your level progress will be lost, but your unlocked skins are safe!</p><div class="button-group"><button id="confirm-quit-button" class="button">Quit</button><button id="cancel-quit-button" class="button secondary-button">Cancel</button></div></div>
            <div id="equip-confirm-screen" class="ui-overlay" style="display: none;"><h1>Equip Fish?</h1><img id="equip-confirm-img" src="" style="width: 150px; height: 150px; object-fit: contain; margin: 15px 0;"><h2 id="equip-confirm-name">Fish Name</h2><div class="button-group"><button id="confirm-equip-button" class="button">Equip</button><button id="cancel-equip-button" class="button secondary-button">Cancel</button></div></div>
        </div>
    </div>

<script>
window.addEventListener('DOMContentLoaded', () => {
    let canvas, ctx, gameContainer, mainMenu, gameOverScreen, fishSelectionModal, gameUIHeader, scoreDisplay, progressBar, perfectPassText, finalScoreDisplay, bestScoreDisplay, startGameButton, restartButton, homeButton, fishButton, closeFishModalButton, fishGrid, loadingScreen, loadingProgress, howToPlayScreen, closeHowToPlayButton, lifeLostScreen, continueButton, livesDisplay, livesRemainingDisplay, levelStartScreen, levelStartName, levelStartObstacleImg, levelStartLives, beginLevelButton, mainMenuBestScore, uiLevelName, godModeIndicator, godModeToggleButtons, lifeLostHomeButton, levelStartHomeButton, unlockScreen, unlockedSkinName, unlockedSkinImg, equipUnlockedSkinButton, continueWithoutEquippingButton, quitWarningScreen, confirmQuitButton, cancelQuitButton, unlockAnimationImg, unlockAnimationContainer, unlockButtons, tapToRevealText, screenFlash, shockEffect, equipConfirmScreen, equipConfirmImg, equipConfirmName, confirmEquipButton, cancelEquipButton, mainMenuBestDistance, finalDistanceDisplay, bestDistanceDisplay, newBestRecordDisplay, pauseButton, pauseScreen, resumeButton, pauseQuitButton;
    let gameState = 'loading'; let lives = 3; let score = 0; let distance = 0; let bestScore = localStorage.getItem('floatyFishBestScore') || 0; let bestDistance = localStorage.getItem('floatyFishBestDistance') || 0; let frame = 0; let survivalTime = 0; let currentLevelIndex = 0; let survivalScoreInterval; let animationFrameId; let godMode = false; let newlyUnlockedSkinId = null; let pendingSkinToEquip = null; let unlockTaps = 0;
    let obstaclesArray = [], jellyfishArray = [], rockArray = [], icebergArray = [], tripleObstaclesArray = [];
    const ASSETS = { fish_default: 'https://raw.githubusercontent.com/cmstewardjr/Floaty-Fish/main/coral%20orange%20fish.png', fish_kelp_green: 'https://raw.githubusercontent.com/cmstewardjr/Floaty-Fish/main/kelp%20green%20fish.png', fish_deep_blue: 'https://raw.githubusercontent.com/cmstewardjr/Floaty-Fish/main/deep%20ocean%20blue%20fish.png', fish_sea_lion_tan: 'https://raw.githubusercontent.com/cmstewardjr/Floaty-Fish/main/Sealion%20Tan%20Fish.png', fish_polkadot: 'https://raw.githubusercontent.com/cmstewardjr/Floaty-Fish/main/Polkadot%20Party%20Fish.png', fish_shark_grey: 'https://raw.githubusercontent.com/cmstewardjr/Floaty-Fish/main/Shark%20Grey%20Fish.png', fish_inky_black: 'https://raw.githubusercontent.com/cmstewardjr/Floaty-Fish/main/Inky%20Black%20Fish.png', fish_orca_mono: 'https://raw.githubusercontent.com/cmstewardjr/Floaty-Fish/main/Orca%20Monochrome%20Fish.png', fish_bioluminescent: 'https://raw.githubusercontent.com/cmstewardjr/Floaty-Fish/main/Bioluminescent%20Fish.png', fish_locked: 'https://raw.githubusercontent.com/cmstewardjr/Floaty-Fish/main/Unlock-Fish.png', octopus: 'https://raw.githubusercontent.com/cmstewardjr/Floaty-Fish/main/Octopus.png', octopus_propel: 'https://raw.githubusercontent.com/cmstewardjr/Floaty-Fish/main/Octopus-propel.png', dolphin: 'https://raw.githubusercontent.com/cmstewardjr/Floaty-Fish/main/Dolphin.png', seal: 'https://raw.githubusercontent.com/cmstewardjr/Floaty-Fish/main/Seal.png', sea_lion: 'https://raw.githubusercontent.com/cmstewardjr/Floaty-Fish/main/Sea%20Lion.png', jellyfish: 'https://raw.githubusercontent.com/cmstewardjr/Floaty-Fish/main/Jellyfish%201.png', jellyfish_propel: 'https://raw.githubusercontent.com/cmstewardjr/Floaty-Fish/main/Jellyfish%201-propel.png', jellyfish_pink: 'https://raw.githubusercontent.com/cmstewardjr/Floaty-Fish/main/Jellyfish%202.png', jellyfish_pink_propel: 'https://raw.githubusercontent.com/cmstewardjr/Floaty-Fish/main/Jellyfish%202-propel.png', jellyfish_yellow: 'https://raw.githubusercontent.com/cmstewardjr/Floaty-Fish/main/Jellyfish%203.png', jellyfish_yellow_propel: 'https://raw.githubusercontent.com/cmstewardjr/Floaty-Fish/main/Jellyfish%203-propel.png', shark: 'https://raw.githubusercontent.com/cmstewardjr/Floaty-Fish/main/Shark.png', squid: 'https://raw.githubusercontent.com/cmstewardjr/Floaty-Fish/main/SQUID.png', squid_propel: 'https://raw.githubusercontent.com/cmstewardjr/Floaty-Fish/main/SQUID-propel.png', orca: 'https://raw.githubusercontent.com/cmstewardjr/Floaty-Fish/main/Orca.png', lantern_fish: 'https://raw.githubusercontent.com/cmstewardjr/Floaty-Fish/main/Lantern%20Fish.png', electric_shock: 'https://raw.githubusercontent.com/cmstewardjr/Floaty-Fish/main/Electric-Shock.png', yellow_rock_1: 'https://raw.githubusercontent.com/cmstewardjr/Floaty-Fish/main/yellow-rock-1.png', yellow_rock_2: 'https://raw.githubusercontent.com/cmstewardjr/Floaty-Fish/main/yellow-rock-2.png', red_rock_1: 'https://raw.githubusercontent.com/cmstewardjr/Floaty-Fish/main/red-rock-1.png', blue_rock_1: 'https://raw.githubusercontent.com/cmstewardjr/Floaty-Fish/main/blue-rock-1.png', blue_rock_2: 'https://raw.githubusercontent.com/cmstewardjr/Floaty-Fish/main/blue-rock-2.png', orange_rock_1: 'https://raw.githubusercontent.com/cmstewardjr/Floaty-Fish/main/orange-rock-1.png', orange_rock_2: 'https://raw.githubusercontent.com/cmstewardjr/Floaty-Fish/main/orange-rock-2.png', iceberg_1: 'https://raw.githubusercontent.com/cmstewardjr/Floaty-Fish/main/iceberg-1.png', iceberg_2: 'https://raw.githubusercontent.com/cmstewardjr/Floaty-Fish/main/iceberg-2.png', iceberg_3: 'https://raw.githubusercontent.com/cmstewardjr/Floaty-Fish/main/iceberg-3.png', iceberg_4: 'https://raw.githubusercontent.com/cmstewardjr/Floaty-Fish/main/iceberg-4.png', };
    const gameConfig = { gravity: 0.22, lift: -6.5, gameSpeed: 3, topBoundary: 0, bottomBoundary: 0, perfectPassTolerance: 20, sandyBottomHeight: 50 };
    const ALL_ROCK_TYPES = ['yellow_rock_1', 'yellow_rock_2', 'red_rock_1', 'blue_rock_1', 'blue_rock_2', 'orange_rock_1', 'orange_rock_2'];
    const VORTEX_ENEMY_TYPES = ['octopus', 'dolphin', 'seal', 'sea_lion', 'shark', 'squid', 'orca', 'lantern_fish'];
    const VORTEX_MOVEMENT_TYPES = ['bobbing', 'sinewave', 'undulating', 'jetting', 'launching'];
    const LEVELS = [ { name: 'Tangle Reef', duration: 60, bgColor: 'linear-gradient(to bottom, #1dd1a1, #138d75)', obstacleImg: 'octopus', speedMultiplier: 1.3, gap: 210, obstacleWidth: 100, movement: 'launching', floorObstacleTypes: ['yellow_rock_1', 'yellow_rock_2'], hasHoming: true }, { name: 'Dolphin Bay', duration: 60, bgColor: 'linear-gradient(to bottom, #00c6ff, #0072ff)', obstacleImg: 'dolphin', speedMultiplier: 1.2, gap: 230, obstacleWidth: 110, movement: 'undulating', floorObstacleTypes: ['blue_rock_1', 'blue_rock_2'], hasHoming: true }, { name: 'Seal Rock', duration: 60, bgColor: 'linear-gradient(to bottom, #a8c0ff, #3f2b96)', obstacleImg: 'seal', speedMultiplier: 1.1, gap: 220, obstacleWidth: 105, movement: 'undulating', topObstacleTypes: ['iceberg_1', 'iceberg_3'], hasHoming: true }, { name: 'Sea Lion Cove', duration: 60, bgColor: 'linear-gradient(to bottom, #f7b733, #fc4a1a)', obstacleImg: 'sea_lion', speedMultiplier: 1.4, gap: 210, obstacleWidth: 115, movement: 'undulating', floorObstacleTypes: ['red_rock_1', 'orange_rock_1'], hasHoming: true }, { name: 'Jellyfish Fields', duration: 60, bgColor: 'linear-gradient(to bottom, #4e54c8, #8f94fb)', speedMultiplier: 1.0, freeFloatingTypes: ['jellyfish', 'jellyfish_pink', 'jellyfish_yellow'], hasHoming: false }, { name: 'Shark Shallows', duration: 60, bgColor: 'linear-gradient(to bottom, #0f2027, #2c5364)', obstacleImg: 'shark', speedMultiplier: 1.8, gap: 220, obstacleWidth: 130, movement: 'sinewave', floorObstacleTypes: ['orange_rock_1', 'orange_rock_2'], hasHoming: true }, { name: 'Squid Ink Spire', duration: 60, bgColor: 'linear-gradient(to bottom, #4A5568, #2D3748)', obstacleImg: 'squid', speedMultiplier: 1.3, gap: 215, obstacleWidth: 100, movement: 'jetting', floorObstacleTypes: ALL_ROCK_TYPES, hasHoming: true }, { name: 'Orca Trench', duration: 60, bgColor: 'linear-gradient(to bottom, #141E30, #243B55)', obstacleImg: 'orca', speedMultiplier: 2.0, gap: 240, obstacleWidth: 150, movement: 'undulating', topObstacleTypes: ['iceberg_2', 'iceberg_4'], hasHoming: true }, { name: 'Abyssal Zone', duration: 60, bgColor: '#000000', obstacleImg: 'lantern_fish', speedMultiplier: 1.4, gap: 220, obstacleWidth: 110, movement: 'sinewave', floorObstacleTypes: ALL_ROCK_TYPES, hasHoming: true }, { name: 'The Vortex', isEndless: true, duration: Infinity, bgColor: 'linear-gradient(to bottom, #C0C0C0, #4682B4)', speedMultiplier: 1.5, gap: 210, obstacleWidth: 110, floorObstacleTypes: ALL_ROCK_TYPES, hasHoming: true } ];
    const FINITE_LEVELS_TOTAL_DURATION = LEVELS.filter(l => l.duration !== Infinity).reduce((acc, level) => acc + level.duration, 0);
    const VORTEX_LEVEL_INDEX = LEVELS.length - 1;
    const SKINS = [ { id: 'fish_default', name: 'Coral Orange', unlockLevel: 0 }, { id: 'fish_kelp_green', name: 'Kelp Green', unlockLevel: 1 }, { id: 'fish_deep_blue', name: 'Deep Ocean Blue', unlockLevel: 2 }, { id: 'fish_sea_lion_tan', name: 'Sea Lion Tan', unlockLevel: 3 }, { id: 'fish_polkadot', name: 'Polkadot Party', unlockLevel: 4 }, { id: 'fish_shark_grey', name: 'Shark Grey', unlockLevel: 5 }, { id: 'fish_inky_black', name: 'Inky Black', unlockLevel: 6 }, { id: 'fish_orca_mono', name: 'Orca Monochrome', unlockLevel: 7 }, { id: 'fish_bioluminescent', name: 'Bioluminescent', unlockLevel: 8 }, ];
    const HITBOXES = { player: [ { w: 0.7, h: 0.6, offsetX: 0, offsetY: 0 } ], octopus: [ { w: 0.7, h: 0.5, offsetX: 0.05, offsetY: -0.2 }, { w: 0.6, h: 0.5, offsetX: -0.05, offsetY: 0.25 } ], squid: [ { w: 0.6, h: 0.5, offsetX: 0, offsetY: -0.25 }, { w: 0.3, h: 0.5, offsetX: 0, offsetY: 0.25 } ], jellyfish: [ { w: 0.7, h: 0.5, offsetX: 0, offsetY: -0.15 }, { w: 0.25, h: 0.5, offsetX: 0, offsetY: 0.25 } ], dolphin: [ { w: 0.9, h: 0.4, offsetX: 0, offsetY: 0 } ], seal: [ { w: 0.9, h: 0.4, offsetX: 0, offsetY: 0 } ], sea_lion: [ { w: 0.9, h: 0.4, offsetX: 0, offsetY: 0 } ], orca: [ { w: 0.95, h: 0.4, offsetX: 0, offsetY: 0 } ], shark: [ { w: 0.95, h: 0.35, offsetX: 0, offsetY: 0 } ], lantern_fish: [ { w: 0.8, h: 0.7, offsetX: 0, offsetY: 0 } ], rock: [ { w: 0.8, h: 0.8, offsetX: 0, offsetY: 0 } ], iceberg: [ { w: 0.8, h: 0.8, offsetX: 0, offsetY: 0 } ] };
    let imageObjects = {};
    const player = { x: 100, y: 250, width: 60, height: 60, dy: 0, currentSkin: 'fish_default', name: 'player', swimFrame: 0, draw() { const img = imageObjects[this.currentSkin]; if (!img || !img.complete || !ctx) return; ctx.save(); ctx.imageSmoothingEnabled = true; const isBioluminescent = this.currentSkin === 'fish_bioluminescent'; const inAbyssalZone = currentLevelIndex === LEVELS.findIndex(l => l.name === 'Abyssal Zone'); if (gameState === 'resuming' && Math.floor(frame / 5) % 2 === 0) { ctx.globalAlpha = 0.5; } if (godMode) { ctx.shadowColor = '#FFD700'; ctx.shadowBlur = 20; } else if (isBioluminescent || inAbyssalZone) { ctx.shadowColor = isBioluminescent ? '#00ffff' : '#ffffff'; ctx.shadowBlur = isBioluminescent ? 20 : 10; } if (inAbyssalZone && !isBioluminescent) { ctx.globalAlpha = 0.25; } ctx.translate(this.x + this.width / 2, this.y + this.height / 2); if (gameState === 'dying') { ctx.rotate(Math.PI); } else { const swimWiggle = Math.sin(this.swimFrame) * 0.1; ctx.rotate(this.dy * 0.05 + swimWiggle); } ctx.drawImage(img, -this.width / 2, -this.height / 2, this.width, this.height); ctx.restore(); }, update() { if (gameState !== 'resuming') { this.dy += gameConfig.gravity; } this.y += this.dy; if (this.y < gameConfig.topBoundary) { this.y = gameConfig.topBoundary; this.dy = 0; const levelHasIcebergs = LEVELS[currentLevelIndex].topObstacleTypes?.length > 0; if (levelHasIcebergs && gameState === 'playing' && !godMode) { handlePlayerHit({name: 'ceiling'}); } } if (this.y + this.height > gameConfig.bottomBoundary) { this.y = gameConfig.bottomBoundary - this.height; this.dy = 0; if (gameState === 'playing' && !godMode) handlePlayerHit({name: 'floor'}); } }, flap() { if (gameState === 'playing') { this.dy = gameConfig.lift; } } };
    class Obstacle { constructor(config = {}) { const level = LEVELS[currentLevelIndex]; this.name = config.name || level.obstacleImg; this.image = imageObjects[this.name]; this.gap = config.gap || level.gap - (Math.random() * 40); this.topPipeHeight = Math.random() * (canvas.height / 2.5 - 50) + 50; this.x = canvas.width; this.width = config.width || level.obstacleWidth; this.counted = false; this.imgHeight = 0; this.speed = (config.speed || gameConfig.gameSpeed * level.speedMultiplier); this.baseSpeed = this.speed; // Store the original speed
        this.movement = config.movement || level.movement; this.hasHoming = config.hasHoming !== undefined ? config.hasHoming : level.hasHoming; // Lunge Attack Properties
        this.hasLunged = false; this.isLunging = false; this.lungeFrameCounter = 0; this.lungeTriggerDistance = 450; // How close the player must be to trigger a lunge
        this.lungeSpeedMultiplier = 3.5; this.lungeDuration = 25; // How many frames the lunge lasts
        if (!this.image || !this.image.width) return; this.imgHeight = (this.width / this.image.width) * this.image.height; this.bottomPipeHeight = canvas.height - this.topPipeHeight - this.gap; }
        update() {
            this.x -= this.speed; // --- AGGRESSIVE VERTICAL STALKING ---
            if (this.hasHoming && this.x > player.x) {
                const lerpFactor = 0.1; // Increased for more aggressive tracking
                const playerCenterY = player.y + player.height / 2;
                const targetGapCenterY = playerCenterY;
                const targetTopPipeHeight = targetGapCenterY - (this.gap / 2);
                this.topPipeHeight += (targetTopPipeHeight - this.topPipeHeight) * lerpFactor;
            } // --- PROXIMITY-BASED LUNGE ATTACK ---
            if (this.movement === 'launching' && !this.hasLunged && this.x < player.x + this.lungeTriggerDistance && this.x > player.x) {
                const playerCenterY = player.y + player.height / 2;
                const gapCenterY = this.topPipeHeight + this.gap / 2; // Check if player is reasonably aligned with the gap
                if (Math.abs(playerCenterY - gapCenterY) < this.gap * 0.75) {
                    this.isLunging = true;
                    this.hasLunged = true; // Ensure it only lunges once
                    this.speed = this.baseSpeed * this.lungeSpeedMultiplier;
                }
            } // --- MANAGE LUNGE DURATION ---
            if (this.isLunging) {
                this.lungeFrameCounter++;
                if (this.lungeFrameCounter > this.lungeDuration) {
                    this.isLunging = false;
                    this.speed = this.baseSpeed; // Return to normal speed after lunge
                }
            } // --- BOUNDARY & STATE UPDATES ---
            const minTopPipeHeight = 50;
            const maxTopPipeHeight = canvas.height - this.gap - this.imgHeight - gameConfig.sandyBottomHeight;
            this.topPipeHeight = Math.max(minTopPipeHeight, Math.min(this.topPipeHeight, maxTopPipeHeight));
            this.bottomPipeHeight = canvas.height - this.topPipeHeight - this.gap;
        }
        draw() { if (this.image && this.image.complete) { ctx.save(); ctx.imageSmoothingEnabled = true; const isLanternFish = this.name === 'lantern_fish'; if (isLanternFish && currentLevelIndex === LEVELS.findIndex(l => l.name === 'Abyssal Zone')) { ctx.globalAlpha = 0.25; } const imgHeight = this.imgHeight; const topY = this.topPipeHeight - imgHeight; const bottomY = canvas.height - this.bottomPipeHeight; ctx.drawImage(this.image, this.x, topY, this.width, imgHeight); ctx.drawImage(this.image, this.x, bottomY, this.width, imgHeight); if (isLanternFish && currentLevelIndex === LEVELS.findIndex(l => l.name === 'Abyssal Zone')) { ctx.globalAlpha = 1.0; const glowRadius = 25; const glowX = this.x + this.width * 0.15; const glowYOffset = imgHeight * 0.3; const createGlow = (gx, gy) => { const gradient = ctx.createRadialGradient(gx, gy, glowRadius * 0.1, gx, gy, glowRadius); gradient.addColorStop(0, 'rgba(255, 255, 224, 0.95)'); gradient.addColorStop(1, 'rgba(255, 215, 0, 0)'); ctx.fillStyle = gradient; ctx.beginPath(); ctx.arc(gx, gy, glowRadius, 0, Math.PI * 2); ctx.fill(); }; createGlow(glowX, topY + glowYOffset); createGlow(glowX, bottomY + glowYOffset); } ctx.restore(); } } }
    class TripleObstacle { constructor(config = {}) { const level = LEVELS[currentLevelIndex]; this.name = config.name || level.obstacleImg; this.image = imageObjects[this.name]; this.parts = []; this.x = canvas.width; this.width = config.width || level.obstacleWidth; this.counted = false; if (!this.image || !this.image.width) return; this.obstacleHeight = (this.width / this.image.width) * this.image.height; this.narrowGap = 115; this.totalUsedHeight = (3 * this.obstacleHeight) + (2 * this.narrowGap); this.speed = config.speed || gameConfig.gameSpeed * level.speedMultiplier; this.baseSpeed = this.speed; this.movement = config.movement || level.movement; this.hasHoming = config.hasHoming !== undefined ? config.hasHoming : level.hasHoming; this.startY = Math.random() * (canvas.height - this.totalUsedHeight - gameConfig.sandyBottomHeight); // Lunge Attack Properties
        this.hasLunged = false; this.isLunging = false; this.lungeFrameCounter = 0; this.lungeTriggerDistance = 450; this.lungeSpeedMultiplier = 3.0; // Slightly slower lunge for this harder obstacle
        this.lungeDuration = 30; this.updatePartsPosition(); }
        update() {
            this.x -= this.speed; // --- AGGRESSIVE VERTICAL STALKING ---
            if (this.hasHoming && this.x > player.x) {
                const lerpFactor = 0.08; // More aggressive tracking
                const playerCenterY = player.y + player.height / 2;
                const targetGroupCenterY = playerCenterY;
                const targetStartY = targetGroupCenterY - (this.totalUsedHeight / 2);
                this.startY += (targetStartY - this.startY) * lerpFactor;
            } // --- PROXIMITY-BASED LUNGE ATTACK ---
            if (this.movement === 'launching' && !this.hasLunged && this.x < player.x + this.lungeTriggerDistance && this.x > player.x) {
                const playerCenterY = player.y + player.height / 2;
                const groupCenterY = this.startY + this.totalUsedHeight / 2;
                if (Math.abs(playerCenterY - groupCenterY) < this.totalUsedHeight * 0.6) {
                    this.isLunging = true;
                    this.hasLunged = true;
                    this.speed = this.baseSpeed * this.lungeSpeedMultiplier;
                }
            } // --- MANAGE LUNGE DURATION ---
            if (this.isLunging) {
                this.lungeFrameCounter++;
                if (this.lungeFrameCounter > this.lungeDuration) {
                    this.isLunging = false;
                    this.speed = this.baseSpeed;
                }
            } // --- BOUNDARY & STATE UPDATES ---
            const minY = 0;
            const maxY = canvas.height - this.totalUsedHeight - gameConfig.sandyBottomHeight;
            this.startY = Math.max(minY, Math.min(this.startY, maxY));
            this.updatePartsPosition();
        }
        updatePartsPosition() { let currentY = this.startY; this.parts = []; this.parts.push({ x: this.x, y: currentY, width: this.width, height: this.obstacleHeight, name: this.name }); currentY += this.obstacleHeight + this.narrowGap; this.parts.push({ x: this.x, y: currentY, width: this.width, height: this.obstacleHeight, name: this.name }); currentY += this.obstacleHeight + this.narrowGap; this.parts.push({ x: this.x, y: currentY, width: this.width, height: this.obstacleHeight, name: this.name }); } draw() { if (this.image && this.image.complete) { ctx.save(); ctx.imageSmoothingEnabled = true; this.parts.forEach(part => { ctx.drawImage(this.image, part.x, part.y, part.width, part.height); }); ctx.restore(); } } }
    class FreeFloatingObstacle { constructor(imageKey) { this.image = imageObjects[imageKey]; this.x = canvas.width + Math.random() * canvas.width; this.y = Math.random() * (gameConfig.bottomBoundary - 100); this.width = 80; this.height = 80; this.speed = gameConfig.gameSpeed * 0.7; this.vy = (Math.random() - 0.5) * 2; this.vx = (Math.random() - 0.5) * 0.5; this.name = 'jellyfish'; } update() { this.x -= this.speed; this.x += this.vx; this.y += this.vy; if (this.y < 50 || this.y > gameConfig.bottomBoundary - this.height - 50) { this.vy *= -1; } } draw() { if (this.image && this.image.complete) { ctx.imageSmoothingEnabled = true; ctx.drawImage(this.image, this.x, this.y, this.width, this.height); } } }
    class StaticEnvironmentObstacle { constructor(imageKey, isTop) { this.image = imageObjects[imageKey]; this.width = 125; this.height = 125; this.x = canvas.width + Math.random() * 200; this.isTop = isTop; if (isTop) { this.y = gameConfig.topBoundary - this.height / 1.5; } else { this.y = canvas.height - this.height; } this.speed = gameConfig.gameSpeed * 1.2; this.name = isTop ? 'iceberg' : 'rock'; this.glows = []; this.isVortexRock = !isTop && currentLevelIndex === VORTEX_LEVEL_INDEX; const isAbyssalRock = !isTop && currentLevelIndex === LEVELS.findIndex(l => l.name === 'Abyssal Zone'); if (isAbyssalRock || this.isVortexRock) { const numGlows = 5 + Math.random() * 5; const glowColors = this.isVortexRock ? ['#FFD700', '#FFA500'] : ['#00ffff', '#39ff14', '#ff00ff', '#f0f']; for (let i = 0; i < numGlows; i++) { this.glows.push({ x: this.width * 0.2 + Math.random() * this.width * 0.6, y: this.height * 0.2 + Math.random() * this.height * 0.6, baseRadius: 1 + Math.random() * 2, radius: 1, color: glowColors[Math.floor(Math.random() * glowColors.length)], offset: Math.random() * Math.PI * 2 }); } } } update() { this.x -= this.speed; if(this.isVortexRock) { this.glows.forEach(glow => { glow.radius = glow.baseRadius + Math.sin(frame * 0.2 + glow.offset) * glow.baseRadius * 0.5; }); } } draw() { if (this.image && this.image.complete) { ctx.save(); ctx.imageSmoothingEnabled = true; const inDarkLevel = currentLevelIndex === LEVELS.findIndex(l => l.name === 'Abyssal Zone') || this.isVortexRock; if (inDarkLevel && this.name === 'rock') { ctx.globalAlpha = 0.4; } ctx.drawImage(this.image, this.x, this.y, this.width, this.height); if (inDarkLevel) { ctx.globalAlpha = 1.0; } if (this.glows.length > 0) { this.glows.forEach(glow => { ctx.fillStyle = glow.color; ctx.shadowColor = glow.color; ctx.shadowBlur = 10; ctx.beginPath(); ctx.arc(this.x + glow.x, this.y + glow.y, glow.radius, 0, Math.PI * 2); ctx.fill(); }); } ctx.restore(); } } }
    function drawBackgroundExtras() { const level = LEVELS[currentLevelIndex]; if (level.floorObstacleTypes && level.floorObstacleTypes.length > 0) { ctx.fillStyle = '#C2B280'; ctx.fillRect(0, gameConfig.bottomBoundary, canvas.width, gameConfig.sandyBottomHeight); } }
    function handleAllObstacles() { const level = LEVELS[currentLevelIndex]; const spawnInterval = currentLevelIndex === VORTEX_LEVEL_INDEX ? 100 : 120; if ((level.obstacleImg || level.isEndless) && frame % spawnInterval === 0) { let config = {}; if (level.isEndless) { config.name = VORTEX_ENEMY_TYPES[Math.floor(Math.random() * VORTEX_ENEMY_TYPES.length)]; config.movement = VORTEX_MOVEMENT_TYPES[Math.floor(Math.random() * VORTEX_MOVEMENT_TYPES.length)]; config.speed = gameConfig.gameSpeed * (1.5 + survivalTime * 0.001); config.hasHoming = true; } if (currentLevelIndex > 0 && Math.random() < 0.35) { tripleObstaclesArray.unshift(new TripleObstacle(config)); } else { obstaclesArray.unshift(new Obstacle(config)); } } if (level.freeFloatingTypes && frame % 30 === 0 && jellyfishArray.length < 10) { jellyfishArray.push(new FreeFloatingObstacle(level.freeFloatingTypes[Math.floor(Math.random() * level.freeFloatingTypes.length)])); } if (level.floorObstacleTypes && frame % 150 === 0) { rockArray.push(new StaticEnvironmentObstacle(level.floorObstacleTypes[Math.floor(Math.random() * level.floorObstacleTypes.length)], false)); } if (level.topObstacleTypes && frame % 180 === 0) { icebergArray.push(new StaticEnvironmentObstacle(level.topObstacleTypes[Math.floor(Math.random() * level.topObstacleTypes.length)], true)); } [...obstaclesArray, ...jellyfishArray, ...rockArray, ...icebergArray, ...tripleObstaclesArray].forEach(o => o.update()); obstaclesArray = obstaclesArray.filter(o => o.x > -o.width); tripleObstaclesArray = tripleObstaclesArray.filter(o => o.x > -o.width); jellyfishArray = jellyfishArray.filter(j => j.x > -j.width); rockArray = rockArray.filter(r => r.x > -r.width); icebergArray = icebergArray.filter(i => i.x > -i.width); }
    function detectCollision(objA, objB) { const partsA = HITBOXES[objA.name] || [{ w: 0.8, h: 0.8, offsetX: 0, offsetY: 0 }]; const partsB = HITBOXES[objB.name] || [{ w: 0.8, h: 0.8, offsetX: 0, offsetY: 0 }]; const centerAx = objA.x + objA.width / 2; const centerAy = objA.y + objA.height / 2; const centerBx = objB.x + objB.width / 2; const centerBy = objB.y + objB.height / 2; for (const partA of partsA) { const wA = objA.width * partA.w; const hA = objA.height * partA.h; const xA = centerAx - wA / 2 + (partA.offsetX || 0) * objA.width; const yA = centerAy - hA / 2 + (partA.offsetY || 0) * objA.height; for (const partB of partsB) { const wB = objB.width * partB.w; const hB = objB.height * partB.h; const xB = centerBx - wB / 2 + (partB.offsetX || 0) * objB.width; const yB = centerBy - hB / 2 + (partB.offsetY || 0) * objB.height; if (xA < xB + wB && xA + wA > xB && yA < yB + hB && yA + hA > yB) { return true; } } } return false; }
    function handleCollisions() { if (godMode) return; for (const o of obstaclesArray) { if (!o.image || o.image.width === 0) continue; const imgHeight = o.imgHeight; const topObstacleSprite = { x: o.x, y: o.topPipeHeight - imgHeight, width: o.width, height: imgHeight, name: o.name }; const bottomObstacleSprite = { x: o.x, y: canvas.height - o.bottomPipeHeight, width: o.width, height: imgHeight, name: o.name }; if (detectCollision(player, topObstacleSprite) || detectCollision(player, bottomObstacleSprite)) { handlePlayerHit(o); return; } } for (const triple of tripleObstaclesArray) { for (const part of triple.parts) { if (detectCollision(player, part)) { handlePlayerHit(triple); return; } } } for (const obs of [...jellyfishArray, ...rockArray, ...icebergArray]) { if (detectCollision(player, obs)) { handlePlayerHit(obs); return; } } }
    function handleScoring() { obstaclesArray.forEach(o => { if (!o.counted && o.x + o.width < player.x) { score += 50; o.counted = true; const gapCenter = o.topPipeHeight + o.gap / 2; if (Math.abs((player.y + player.height / 2) - gapCenter) < gameConfig.perfectPassTolerance) { score += 100; perfectPassText.style.opacity = 1; setTimeout(() => { perfectPassText.style.opacity = 0; }, 1000); } } }); tripleObstaclesArray.forEach(o => { if (!o.counted && o.x + o.width < player.x) { score += 100; o.counted = true; } }); }
    function handleLevelChange() { if (currentLevelIndex === VORTEX_LEVEL_INDEX) return; let effectiveTime = survivalTime / 60; let cumulativeDuration = 0; let newLevelIndex = -1; for (let i = 0; i < VORTEX_LEVEL_INDEX; i++) { if (effectiveTime < cumulativeDuration + LEVELS[i].duration) { newLevelIndex = i; break; } cumulativeDuration += LEVELS[i].duration; } if (newLevelIndex === -1 && effectiveTime >= FINITE_LEVELS_TOTAL_DURATION) { newLevelIndex = VORTEX_LEVEL_INDEX; } if (newLevelIndex !== -1 && newLevelIndex !== currentLevelIndex) { stopIntervals(); cancelAnimationFrame(animationFrameId); currentLevelIndex = newLevelIndex; uiLevelName.textContent = LEVELS[currentLevelIndex].name; newlyUnlockedSkinId = unlockSkinForLevel(currentLevelIndex); if (newlyUnlockedSkinId) { showUnlockScreen(); } else { showLevelStartScreen(); } } else if (newLevelIndex !== -1) { const progressInLevel = (effectiveTime - cumulativeDuration) / LEVELS[newLevelIndex].duration * 100; progressBar.style.width = `${Math.min(progressInLevel, 100)}%`; gameContainer.style.background = LEVELS[newLevelIndex].bgColor; } }
    function triggerShockAnimation() { shockEffect.style.left = `${player.x + player.width / 2}px`; shockEffect.style.top = `${player.y + player.height / 2}px`; shockEffect.style.display = 'block'; screenFlash.classList.add('active'); setTimeout(() => { shockEffect.style.display = 'none'; screenFlash.classList.remove('active'); }, 200); }
    function animate() { if (gameState === 'level-start' || gameState === 'unlocking' || gameState === 'unlock-revealed' || gameState === 'life-lost' || gameState === 'game-over' || gameState === 'menu' || gameState === 'paused') return; ctx.clearRect(0, 0, canvas.width, canvas.height); drawBackgroundExtras(); if (gameState === 'playing' || gameState === 'resuming') { player.swimFrame += 0.1; handleAllObstacles(); if (gameState === 'playing') { handleCollisions(); handleScoring(); handleLevelChange(); } } [...obstaclesArray, ...tripleObstaclesArray, ...jellyfishArray, ...rockArray, ...icebergArray].forEach(o => o.draw()); player.update(); player.draw(); scoreDisplay.textContent = Math.floor(score); frame++; animationFrameId = requestAnimationFrame(animate); }
    function beginLevel() { levelStartScreen.style.display = 'none'; gameUIHeader.style.display = 'flex'; gameState = 'playing'; startIntervals(); animate(); }
    function handlePlayerHit(obstacle = {}) { if (gameState !== 'playing') return; if (obstacle.name === 'jellyfish') { triggerShockAnimation(); } gameState = 'dying'; stopIntervals(); setTimeout(() => { lives--; updateLivesDisplay(); if (lives > 0) { gameState = 'life-lost'; livesRemainingDisplay.textContent = `${lives} ${lives > 1 ? 'Lives' : 'Life'} Remaining`; lifeLostScreen.style.display = 'flex'; } else { handleGameOver(); } }, 1000); }
    function continueGame() { lifeLostScreen.style.display = 'none'; player.y = 250; player.dy = 0; obstaclesArray = obstaclesArray.filter(o => o.x > player.x + 150); tripleObstaclesArray = tripleObstaclesArray.filter(o => o.x > player.x + 150); jellyfishArray = jellyfishArray.filter(j => j.x > player.x + 150); gameState = 'resuming'; animate(); setTimeout(() => { gameState = 'playing'; startIntervals(); }, 1000); }
    function handleGameOver() { gameState = 'game-over'; const hasCheated = localStorage.getItem('floatyFishGodModeUsed') === 'true'; if (!hasCheated && score > bestScore) { bestScore = score; localStorage.setItem('floatyFishBestScore', bestScore); } if (!hasCheated && distance > bestDistance) { bestDistance = distance; localStorage.setItem('floatyFishBestDistance', bestDistance); newBestRecordDisplay.style.display = 'block'; } else { newBestRecordDisplay.style.display = 'none'; } finalScoreDisplay.textContent = `SCORE: ${Math.floor(score)}`; bestScoreDisplay.textContent = `BEST: ${Math.floor(bestScore)}`; finalDistanceDisplay.textContent = `DISTANCE: ${Math.floor(distance)}m`; bestDistanceDisplay.textContent = `BEST: ${Math.floor(bestDistance)}m`; gameUIHeader.style.display = 'none'; gameOverScreen.style.display = 'flex'; }
    function updateLivesDisplay() { livesDisplay.innerHTML = ''; const fishIconSrc = imageObjects[player.currentSkin]?.src; if (!fishIconSrc) return; for (let i = 0; i < lives; i++) { const lifeImg = document.createElement('img'); lifeImg.src = fishIconSrc; lifeImg.alt = 'Life'; livesDisplay.appendChild(lifeImg); } }
    function startIntervals() { if (survivalScoreInterval) clearInterval(survivalScoreInterval); survivalScoreInterval = setInterval(() => { if (gameState === 'playing') { survivalTime++; distance += (gameConfig.gameSpeed * (LEVELS[currentLevelIndex].speedMultiplier || 1)) / 60; } }, 1000 / 60); }
    function stopIntervals() { clearInterval(survivalScoreInterval); }
    function resetForNewGame() { score = 0; distance = 0; frame = 0; survivalTime = 0; currentLevelIndex = 0; resetPerLevel(); }
    function resetPerLevel() { player.y = 250; player.dy = 0; obstaclesArray = []; jellyfishArray = []; rockArray = []; icebergArray = []; tripleObstaclesArray = []; lives = 3; stopIntervals(); scoreDisplay.textContent = Math.floor(score); progressBar.style.width = '0%'; gameOverScreen.style.display = 'none'; lifeLostScreen.style.display = 'none'; }
    function showMainMenu() { resetForNewGame(); mainMenu.style.display = 'flex'; gameUIHeader.style.display = 'none'; quitWarningScreen.style.display = 'none'; howToPlayScreen.style.display = 'none'; fishSelectionModal.style.display = 'none'; fishSelectionModal.style.filter = 'none'; levelStartScreen.style.display = 'none'; unlockScreen.style.display = 'none'; equipConfirmScreen.style.display = 'none'; gameState = 'menu'; mainMenuBestScore.textContent = `BEST SCORE: ${Math.floor(bestScore)}`; mainMenuBestDistance.textContent = `BEST DIST: ${Math.floor(bestDistance)}m`; ctx.clearRect(0, 0, canvas.width, canvas.height); player.draw(); }
    function showLevelStartScreen() { resetPerLevel(); const level = LEVELS[currentLevelIndex]; const fishIconSrc = imageObjects[player.currentSkin]?.src; mainMenu.style.display = 'none'; gameUIHeader.style.display = 'none'; unlockScreen.style.display = 'none'; levelStartName.textContent = level.name; uiLevelName.textContent = level.name; godModeToggleButtons.forEach(btn => btn.classList.toggle('active', godMode)); const obstacleKey = level.obstacleImg || level.freeFloatingTypes?.[0] || 'octopus'; levelStartObstacleImg.src = imageObjects[obstacleKey]?.src; levelStartObstacleImg.alt = level.name; levelStartLives.innerHTML = ''; if (fishIconSrc) { for (let i = 0; i < lives; i++) { const lifeImg = document.createElement('img'); lifeImg.src = fishIconSrc; lifeImg.alt = 'Life'; levelStartLives.appendChild(lifeImg); } } updateLivesDisplay(); gameState = 'level-start'; levelStartScreen.style.display = 'flex'; }
    function showUnlockScreen() { const skin = SKINS.find(s => s.id === newlyUnlockedSkinId); if (!skin) { showLevelStartScreen(); return; } gameState = 'unlocking'; unlockTaps = 0; unlockedSkinName.textContent = skin.name; unlockedSkinImg.src = ASSETS[skin.id]; unlockedSkinImg.classList.remove('pop-in'); unlockAnimationImg.src = ASSETS.fish_locked; unlockAnimationImg.style.clipPath = ''; unlockAnimationImg.classList.remove('fade-out'); tapToRevealText.style.display = 'block'; unlockButtons.classList.add('hidden'); unlockScreen.style.display = 'flex'; }
    function handleUnlockTap() { if (gameState !== 'unlocking') return; unlockTaps++; unlockAnimationImg.classList.remove('shake-on-tap'); void unlockAnimationImg.offsetWidth; unlockAnimationImg.classList.add('shake-on-tap'); const clipPaths = [ 'polygon(0% 0%, 100% 0%, 100% 100%, 80% 100%, 70% 80%, 30% 100%, 0 100%)', 'polygon(0 0, 80% 0, 100% 20%, 100% 80%, 70% 80%, 30% 100%, 0 100%, 0% 30%)', 'polygon(0 20%, 30% 0, 80% 0, 100% 20%, 80% 40%, 100% 80%, 70% 80%, 30% 100%, 0 100%, 20% 60%)' ]; if (unlockTaps <= 3) { unlockAnimationImg.style.clipPath = clipPaths[unlockTaps - 1]; } if (unlockTaps >= 4) { gameState = 'unlock-revealed'; tapToRevealText.style.display = 'none'; unlockAnimationImg.classList.add('fade-out'); unlockedSkinImg.classList.add('pop-in'); setTimeout(() => { unlockButtons.classList.remove('hidden'); }, 500); } }
    function loadUnlockedSkins() { const storedSkins = JSON.parse(localStorage.getItem('floatyFishUnlockedSkins') || '[]'); const unlockedSkinsSet = new Set(storedSkins); unlockedSkinsSet.add(SKINS[0].id); return Array.from(unlockedSkinsSet); }
    function unlockSkinForLevel(levelIndex) { if (godMode) return null; const skinToUnlock = SKINS.find(s => s.unlockLevel === levelIndex); if (skinToUnlock) { let unlockedSkins = loadUnlockedSkins(); if (!unlockedSkins.includes(skinToUnlock.id)) { unlockedSkins.push(skinToUnlock.id); localStorage.setItem('floatyFishUnlockedSkins', JSON.stringify(unlockedSkins)); console.log(`Unlocked: ${skinToUnlock.name}!`); return skinToUnlock.id; } } return null; }
    function populateFishSelection() { fishGrid.innerHTML = ''; const unlockedSkins = loadUnlockedSkins(); const selectedSkin = localStorage.getItem('floatyFishSelectedSkin') || 'fish_default'; SKINS.forEach(skin => { const isUnlocked = unlockedSkins.includes(skin.id); const div = document.createElement('div'); div.className = 'fish-option'; div.dataset.skinId = skin.id; if (!isUnlocked) div.classList.add('locked'); if (skin.id === selectedSkin) div.classList.add('selected'); const imgSrc = isUnlocked ? ASSETS[skin.id] : ASSETS.fish_locked; const altText = isUnlocked ? skin.name : 'Locked Fish'; div.innerHTML = `<img src="${imgSrc}" alt="${altText}"><span>${isUnlocked ? skin.name : '???'}</span>`; if (isUnlocked) { div.addEventListener('click', (e) => { e.stopPropagation(); pendingSkinToEquip = skin; equipConfirmImg.src = ASSETS[skin.id]; equipConfirmName.textContent = skin.name; fishSelectionModal.style.filter = 'blur(5px) brightness(0.7)'; equipConfirmScreen.style.display = 'flex'; }); } fishGrid.appendChild(div); }); }
    function toggleGodMode() { godMode = !godMode; godModeIndicator.style.display = godMode ? 'block' : 'none'; godModeToggleButtons.forEach(btn => btn.classList.toggle('active', godMode)); console.log(`God Mode is ${godMode ? 'ON' : 'OFF'}`); if (godMode && !localStorage.getItem('floatyFishGodModeUsed')) { localStorage.setItem('floatyFishGodModeUsed', 'true'); console.warn("God mode activated. Progress will not be saved."); } }
    function getDOMElements() { canvas = document.getElementById('game-canvas'); ctx = canvas.getContext('2d'); gameContainer = document.getElementById('game-container'); loadingScreen = document.getElementById('loading-screen'); loadingProgress = document.getElementById('loading-progress'); howToPlayScreen = document.getElementById('how-to-play-screen'); closeHowToPlayButton = document.getElementById('close-how-to-play-button'); mainMenu = document.getElementById('main-menu'); gameOverScreen = document.getElementById('game-over-screen'); fishSelectionModal = document.getElementById('fish-selection-modal'); gameUIHeader = document.getElementById('game-ui-header'); scoreDisplay = document.getElementById('score-display'); progressBar = document.getElementById('progress-bar'); perfectPassText = document.getElementById('perfect-pass-text'); finalScoreDisplay = document.getElementById('final-score-display'); bestScoreDisplay = document.getElementById('best-score-display'); startGameButton = document.getElementById('start-game-button'); restartButton = document.getElementById('restart-button'); homeButton = document.getElementById('home-button'); fishButton = document.getElementById('fish-button'); closeFishModalButton = document.getElementById('close-fish-modal-button'); fishGrid = document.getElementById('fish-grid'); lifeLostScreen = document.getElementById('life-lost-screen'); continueButton = document.getElementById('continue-button'); livesDisplay = document.getElementById('lives-display'); livesRemainingDisplay = document.getElementById('lives-remaining-display'); levelStartScreen = document.getElementById('level-start-screen'); levelStartName = document.getElementById('level-start-name'); levelStartObstacleImg = document.getElementById('level-start-obstacle-img'); levelStartLives = document.getElementById('level-start-lives'); beginLevelButton = document.getElementById('begin-level-button'); mainMenuBestScore = document.getElementById('main-menu-best-score'); uiLevelName = document.getElementById('ui-level-name'); godModeIndicator = document.getElementById('god-mode-indicator'); godModeToggleButtons = document.querySelectorAll('.god-mode-toggle-button'); lifeLostHomeButton = document.getElementById('life-lost-home-button'); levelStartHomeButton = document.getElementById('level-start-home-button'); unlockScreen = document.getElementById('unlock-screen'); unlockedSkinName = document.getElementById('unlocked-skin-name'); unlockedSkinImg = document.getElementById('unlocked-skin-img'); equipUnlockedSkinButton = document.getElementById('equip-unlocked-skin-button'); continueWithoutEquippingButton = document.getElementById('continue-without-equipping-button'); quitWarningScreen = document.getElementById('quit-warning-screen'); confirmQuitButton = document.getElementById('confirm-quit-button'); cancelQuitButton = document.getElementById('cancel-quit-button'); unlockAnimationImg = document.getElementById('unlock-animation-img'); unlockAnimationContainer = document.getElementById('unlock-animation-container'); unlockButtons = document.getElementById('unlock-buttons'); tapToRevealText = document.getElementById('tap-to-reveal-text'); screenFlash = document.getElementById('screen-flash'); shockEffect = document.getElementById('shock-effect'); equipConfirmScreen = document.getElementById('equip-confirm-screen'); equipConfirmImg = document.getElementById('equip-confirm-img'); equipConfirmName = document.getElementById('equip-confirm-name'); confirmEquipButton = document.getElementById('confirm-equip-button'); cancelEquipButton = document.getElementById('cancel-equip-button'); mainMenuBestDistance = document.getElementById('main-menu-best-distance'); finalDistanceDisplay = document.getElementById('final-distance-display'); bestDistanceDisplay = document.getElementById('best-distance-display'); newBestRecordDisplay = document.getElementById('new-best-record-display'); pauseButton = document.getElementById('pause-button'); pauseScreen = document.getElementById('pause-screen'); resumeButton = document.getElementById('resume-button'); pauseQuitButton = document.getElementById('pause-quit-button'); }
    function setupEventListeners() { const action = () => { if (gameState === 'playing') player.flap(); }; gameContainer.addEventListener('click', e => { if (e.target.tagName === 'BUTTON' || e.target.closest('.fish-option')) return; e.preventDefault(); action(); }); window.addEventListener('keydown', e => { if (e.code === 'Space') { e.preventDefault(); action(); } if (e.code === 'KeyG') { toggleGodMode(); } }); godModeToggleButtons.forEach(btn => btn.addEventListener('click', e => { e.stopPropagation(); toggleGodMode(); })); closeHowToPlayButton.addEventListener('click', e => { e.stopPropagation(); showMainMenu(); }); startGameButton.addEventListener('click', e => { e.stopPropagation(); showLevelStartScreen(); }); restartButton.addEventListener('click', e => { e.stopPropagation(); showLevelStartScreen(); }); beginLevelButton.addEventListener('click', e => { e.stopPropagation(); beginLevel(); }); continueButton.addEventListener('click', e => { e.stopPropagation(); continueGame(); }); homeButton.addEventListener('click', e => { e.stopPropagation(); showMainMenu(); }); fishButton.addEventListener('click', e => { e.stopPropagation(); gameState = 'fish-selection'; mainMenu.style.display = 'none'; populateFishSelection(); fishSelectionModal.style.display = 'flex'; ctx.clearRect(0, 0, canvas.width, canvas.height); player.draw(); }); closeFishModalButton.addEventListener('click', e => { e.stopPropagation(); showMainMenu(); }); lifeLostHomeButton.addEventListener('click', e => { e.stopPropagation(); quitWarningScreen.style.display = 'flex'; }); levelStartHomeButton.addEventListener('click', e => { e.stopPropagation(); quitWarningScreen.style.display = 'flex'; }); confirmQuitButton.addEventListener('click', e => { e.stopPropagation(); showMainMenu(); }); cancelQuitButton.addEventListener('click', e => { e.stopPropagation(); quitWarningScreen.style.display = 'none'; }); unlockAnimationContainer.addEventListener('click', handleUnlockTap); equipUnlockedSkinButton.addEventListener('click', e => { e.stopPropagation(); player.currentSkin = newlyUnlockedSkinId; localStorage.setItem('floatyFishSelectedSkin', player.currentSkin); showLevelStartScreen(); }); continueWithoutEquippingButton.addEventListener('click', e => { e.stopPropagation(); showLevelStartScreen(); }); confirmEquipButton.addEventListener('click', e => { e.stopPropagation(); if (pendingSkinToEquip) { player.currentSkin = pendingSkinToEquip.id; localStorage.setItem('floatyFishSelectedSkin', player.currentSkin); document.querySelectorAll('.fish-option').forEach(el => el.classList.remove('selected')); const gridOption = fishGrid.querySelector(`[data-skin-id="${pendingSkinToEquip.id}"]`); if (gridOption) { gridOption.classList.add('selected'); } ctx.clearRect(0, 0, canvas.width, canvas.height); player.draw(); updateLivesDisplay(); } equipConfirmScreen.style.display = 'none'; fishSelectionModal.style.filter = 'none'; pendingSkinToEquip = null; }); cancelEquipButton.addEventListener('click', e => { e.stopPropagation(); equipConfirmScreen.style.display = 'none'; fishSelectionModal.style.filter = 'none'; pendingSkinToEquip = null; }); pauseButton.addEventListener('click', e => { e.stopPropagation(); if (gameState === 'playing') { gameState = 'paused'; cancelAnimationFrame(animationFrameId); stopIntervals(); pauseScreen.style.display = 'flex'; } }); resumeButton.addEventListener('click', e => { e.stopPropagation(); pauseScreen.style.display = 'none'; gameState = 'playing'; startIntervals(); animate(); }); pauseQuitButton.addEventListener('click', e => { e.stopPropagation(); pauseScreen.style.display = 'none'; quitWarningScreen.style.display = 'flex'; }); }
    function loadAssetsAndInit() { getDOMElements(); if (localStorage.getItem('floatyFishGodModeUsed') === 'true') { console.warn("God Mode has been used. All progress has been reset."); localStorage.removeItem('floatyFishUnlockedSkins'); localStorage.removeItem('floatyFishSelectedSkin'); localStorage.removeItem('floatyFishBestScore'); localStorage.removeItem('floatyFishBestDistance'); bestScore = 0; bestDistance = 0; } canvas.width = 480; canvas.height = 560; gameConfig.bottomBoundary = canvas.height - gameConfig.sandyBottomHeight; player.currentSkin = localStorage.getItem('floatyFishSelectedSkin') || 'fish_default'; bestScoreDisplay.textContent = `BEST: ${Math.floor(bestScore)}`; shockEffect.src = ASSETS.electric_shock; setupEventListeners(); const assetKeys = Object.keys(ASSETS); let totalImages = assetKeys.filter(key => ASSETS[key] !== '').length; if (totalImages === 0) { loadingScreen.style.display = 'none'; howToPlayScreen.style.display = 'flex'; gameState = 'how-to-play'; return; } let imagesLoaded = 0; loadingProgress.textContent = `0%`; assetKeys.forEach(key => { if (ASSETS[key] === '') return; imageObjects[key] = new Image(); imageObjects[key].src = ASSETS[key]; imageObjects[key].onload = () => { imagesLoaded++; const percent = Math.floor((imagesLoaded / totalImages) * 100); if (loadingProgress) loadingProgress.textContent = `${percent}%`; if (imagesLoaded === totalImages) { loadingScreen.style.display = 'none'; howToPlayScreen.style.display = 'flex'; gameState = 'how-to-play'; } }; imageObjects[key].onerror = () => { console.error(`Failed to load asset: ${key}`); imagesLoaded++; if (imagesLoaded === totalImages) { loadingScreen.style.display = 'none'; howToPlayScreen.style.display = 'flex'; gameState = 'how-to-play'; } } }); }
    loadAssetsAndInit();
});
</script>
</body>
</html>
